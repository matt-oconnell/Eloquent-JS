this["JST"] = this["JST"] || {};

this["JST"]["./modules/templates/DefiningFunctions.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>There are several ways to define a function in JavaScript. We'll take a look at a few here.</p>\n\n<p>Function Declaration:</p>\n<pre>\nfunction example() {\n    return true\n}\n</pre>\n<p>Function Expression:</p>\n<pre>\nvar example = function() {\n    return true;\n}\n</pre>\n\n<p>Both examples do pretty much the same thing with one subtle difference. The function declaration is not included in the regular control flow. They are <em>hoisted</em> to the top of whatever scope they reside in. This means you can call the function before it's written in your code.</p>\n<pre>\nex1();\n// 1\nfunction ex1() {\n    return 1;\n}\n\nex2();\n// Uncaught TypeError: ex2 is not a function\nvar ex2 = function() {\n    return 2;\n}\n</pre>\n\n<p>What's happening here? The variable <code>ex2</code> <em>is</em> actually getting hoisted to the top of it's scope, similarly to a function. <em>But</em>, the contents of the variable do <em>not</em> get hoisted. The environment is recognizing <code>ex2</code> as an undefined value.</p>";
},"useData":true});

this["JST"]["./modules/templates/Intro.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>This is a running collection of notes related to the book <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a> (2nd Edition) by <a href=\"https://marijnhaverbeke.nl/\">Marijn Haverbeke</a>. It was built with the intent of clarifying and solidifying some of the more interesting and/or obscure elements of the JavaScript language.</p>\n<p>The material is intended for those who have a good grasp of JavaScript but would like to fill in the gaps.</p>\n\n<blockquote>\"Below the surface of the machine, the program moves. Without effort, it expands and contracts. In great harmony, electrons scatter and regroup. The forms on the monitor are but ripples in the water. The essense stays invisibly below.\"<br><br>- Aster Yuan-Ma, <em>The Book of Programming</em></blockquote>";
},"useData":true});

this["JST"]["./modules/templates/NaN.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>This is the only value in JavaScript that is not equal to itself.</p>\n\n<blockquote>NaN is supposed to denote the result of a nonsensical computation and as such, it isn't equal to the result of <em>other</em> nonsensical compoutations.</blockquote>";
},"useData":true});

this["JST"]["./modules/templates/Recursion.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>Recursion in programming is simply a function that calls itself. </p>";
},"useData":true});

this["JST"]["./modules/templates/TypeConversion.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>JavaScript's automatic type conversion or <em>type coersion</em> can be tricky. When a statement expects a value of a certain type and the expression passed to it does not return one of that type, JavaScript will attempt to convert the given expression into the type it is looking for.</p>\n\n<pre>\nvar e = {ex:1};\nif(e) {\n    // converted from an object to boolean\n}\n</pre>\n\n<p>Usually, this is helpful, but sometimes it can lead to unexpected results. For example, the + operator will always concatenate values if one is a string, otherwise it will add two values together. In the example below, the number 1 is converted to a string.</p>\n<pre>\n'99' + 1\n// '991'\n</pre>\n\n<p>But, the - operator will trigger a type conversion when applied to a string or strings, attempting to convert them to numeric values.</p>\n<pre>\n'99' - '1'\n// 98\n</pre>\n\n<p><code class=\"language-javascript\">true</code> converts to 1 when expected in an arithmetic operation and <code>null</code> converts to 0</p>\n<pre>\ntrue + 2\n// 3\nnull * 1\n// 0\n</pre>\n\n<p>Logical operators (<code>||</code> or <code>&&</code>) work on all types. They <em>expect</em> boolean values though, so when presented with a non-boolean, they will convert it. If it converts to true, they return the <em>original</em> value. For this reason, logical operators are extremely useful in allowing for fallback values and null checks.</p>\n<p>The below code is an example of 'short-circuiting' an evaluation. Since a is <code>null</code>, we fall back to the secondary value. But, if a had evaluated to <code>true</code>, then the second expression would <em>never</em> be evaluated.</p>\n<pre>\nvar a = null\nvar b = a || 'fallback value'\nb // 'fallback value'\n</pre>\n<p>Below, we are using the logical operator to perform a null check on a value we receieved for an imaginary API. If we tried to access c.inner.inner without the null check and <code>c</code> or <code>c.inner</code> did not exist, we would get a \"Cannot read property 'inner' of undefined error.\" But, since we performed the check, the worst that can happen is the <code>if</code> conditional returns false and the program moves right along.</p>\n<pre>\nvar c = getSomeAPIDataInJSON();\nif(c && c.inner && c.inner.inner) {\n    console.log(c.inner.inner);\n}\n</pre>\n\n\n\n<p><code>==</code> checks for equality regardless of the type. Type conversion is performed here.</p>\n<p><code>===</code> checks for equality <em>and</em> matching type. It actually runs faster since we are avoiding a type conversion here. This should be used when possible.</p>\n\n<pre>\nnull == 0\n// false\nnull == ''\n// false\nnull == false\n// false\nnull == undefined\n// true\nnull === undefined\n// false\n</pre>\n\n<p>What counts as false?</p>\n<pre>\n'' == false\nNaN == false\n0 == false\nundefined == false\n// all true\n</pre>\n\n";
},"useData":true});