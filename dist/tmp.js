this["JST"] = this["JST"] || {};

this["JST"]["./modules/templates/DefiningFunctions.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>There are several ways to define a function in JavaScript. We'll take a look at a few here.</p>\n\n<p>Function Declaration:</p>\n<pre>\nfunction example() {\n    return true\n}\n</pre>\n<p>Function Expression:</p>\n<pre>\nvar example = function() {\n    return true;\n}\n</pre>\n\n<p>Both examples do pretty much the same thing with one subtle difference. The function declaration is not included in the regular control flow. They are <em>hoisted</em> to the top of whatever scope they reside in. This means you can call the function before it's written in your code.</p>\n<pre>\nex1();\n// 1\nfunction ex1() {\n    return 1;\n}\n\nex2();\n// Uncaught TypeError: ex2 is not a function\nvar ex2 = function() {\n    return 2;\n}\n</pre>\n\n<p>What's happening here? The variable <code>ex2</code> <em>is</em> actually getting hoisted to the top of it's scope, similarly to a function. <em>But</em>, the contents of the variable do <em>not</em> get hoisted. The environment is recognizing <code>ex2</code> as an undefined value.</p>";
},"useData":true});

this["JST"]["./modules/templates/Formatting.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<h1>H1</h1>\n<h2>H2</h2>\n<h3>H3</h3>\n<h4>H4</h4>\n<h5>H5</h5>\n\n<p>Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, Paragraph, </p>\n\n<blockquote>Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it, Blockin' it</blockquote>\n\n<pre class=\"javascript\">\n    var code = \"I'm a code\";\n    function showMe() {\n        console.log('Shown');\n    }\n    // Comments explaining everything\n</pre>\n\n<button>Click Me!</button>\n\n<tt>Teletype tag?</tt>\n<br>\n<a href=\"http://matto.xyz\">I'm a Link</a>\n\n<ul>\n    <li>List Item 1</li>\n    <li>List Item 2</li>\n</ul>";
},"useData":true});

this["JST"]["./modules/templates/Intro.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>This is a running collection of notes related to the book <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a> (2nd Edition) by <a href=\"https://marijnhaverbeke.nl/\">Marijn Haverbeke</a>. It was built with the intent of clarifying and solidifying some of the more interesting and/or obscure elements of the JavaScript language.</p>\n<p>The material is intended for those who have a good grasp of JavaScript but would like to fill in the gaps.</p>\n\n<blockquote>\"Below the surface of the machine, the program moves. Without effort, it expands and contracts. In great harmony, electrons scatter and regroup. The forms on the monitor are but ripples in the water. The essense stays invisibly below.\"<br><br>- Aster Yuan-Ma, <em>The Book of Programming</em></blockquote>";
},"useData":true});

this["JST"]["./modules/templates/LinkedLists.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<h3>Singles</h3>\n\n<pre>function LinkedList() {\n    this._head = null;\n}</pre>\n\n<pre>\nLinkedList.prototype = {\n    add: function (data){\n        //create a new node, place data in\n        var node = {\n                data: data,\n                next: null,\n            },\n            current;\n        if (this._head === null){\n            this._head = node;\n        } else {\n            current = this._head;\n\n            while(current.next){\n                current = current.next;\n            }\n\n            current.next = node;\n        }\n    },\n};\n</pre>\nhi";
},"useData":true});

this["JST"]["./modules/templates/MongoBasics.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<h3>Find</h3>\n\n<p>Find all restaurant that have the borough Manhattan.</p>\n<pre>\ndb.restaurants.find( { \"borough\": \"Manhattan\" } )\n</pre>\n\n<p>Find all restaurants that have the address.zipcode value 10075. When using dot notation, quotes are necessary.</p>\n<pre>\ndb.restaurants.find( { \"address.zipcode\": \"10075\" } )\n</pre>\n\n<p>Find all restaurants where the grade property inside of the grades array is = to B</p>\n<pre>\ndb.restaurants.find( { \"grades.grade\": \"B\" } )\n</pre>\n\n<h3>Comparison Operators</h3>\n\n<p>Find all with at least one embedded document with score > 30</p>\n<pre>db.restaurants.find( { \"grades.score\": { $gt: 30 } } )</pre>\n\n<p>Logical AND<br><em>Numbers must be in quotes</em></p>\n<pre>db.restaurants.find( { \"cuisine\":\"french\", \"address.zipcode\": \"10016\" } )</pre>\n\n<p>Logical OR</p>\n<pre>\ndb.restaurants.find( { $or [ \"cuisine\":\"french\", \"address.zipcode\": \"10016\" ] } )\n</pre>\n\n<h3>Sorting</h3>\n<p>Sort by borough in ascending order and address in descending</p>\n<pre>\ndb.restaurants.find().sort( { \"borough\": 1, \"address.zipcode\": -1 } )\n</pre>\n\n<h3>Update</h3>\n<p>After the following update, the modified document will only contain the _id field, name field, the address field. i.e. the document will not contain the restaurant_id, cuisine, grades, and the borough fields.</p>\n<pre>\ndb.restaurants.update(\n    { \"name\" : \"Juni\" },\n    {\n      $set: { \"cuisine\": \"American (New)\" },\n      $currentDate: { \"lastModified\": true }\n    }\n)\n</pre>\n<p>If no document matches the update condition, the default behavior of the update method is to do nothing. By specifying the upsert option to true, the update operation either updates matching document(s) or inserts a new document if no matching document exists. In the MongoDB Manual, see update().</p>\n<p>\nIn MongoDB, write operations are atomic on the level of a single document. If a single update operation modifies multiple documents of a collection, the operation can interleave with other write operations on that collection. In the MongoDB Manual, see Atomicity.</p>\n\n<h3>Atomicity and Transactions</h3>\n<p>In MongoDB, a write operation is atomic on the level of a single document, even if the operation modifies multiple embedded documents within a single document.</p>\n<p>When a single write operation modifies multiple documents, the modification of each document is atomic, but the operation as a whole is not atomic and other operations may interleave. However, you can isolate a single write operation that affects multiple documents using the $isolated operator.</p>\n\n<h3>$isolated Operator</h3>\n<p>Using the $isolated operator, a write operation that affect multiple documents can prevent other processes from interleaving once the write operation modifies the first document. This ensures that no client sees the changes until the write operation completes or errors out.</p>\n\n<p>Isolated write operation does not provide \"all-or-nothing\" atomicity. That is, an error during the write operation does not roll back all its changes that preceded the error.</p>\n\n<p>For an example of an update operation that uses the $isolated operator, see $isolated. For an example of a remove operation that uses the $isolated operator, see Isolate Remove Operations.</p>\n\n<h3>Transaction-Like Semantics</h3>\n\n<p>Since a single document can contain multiple embedded documents, single-document atomicity is sufficient for many practical use cases. For cases where a sequence of write operations must operate as if in a single transaction, you can implement a two-phase commit in your application.\n    <br>\nHowever, two-phase commits can only offer transaction-like semantics. Using two-phase commit ensures data consistency, but it is possible for applications to return intermediate data during the two-phase commit or rollback.</p>\n\n<h3>Concurrency Control</h3>\n<p>Concurrency control allows multiple applications to run concurrently without causing data inconsistency or conflicts.\n    <br>\nAn approach may be to create a unique index on a field (or fields) that should have only unique values (or unique combination of values) prevents duplicate insertions or updates that result in duplicate values. For examples of use cases, see update() and Unique Index and findAndModify() and Unique Index.\n    <br>\nAnother approach is to specify the expected current value of a field in the query predicate for the write operations. For an example, see Update if Current.\n    <br>\nThe two-phase commit pattern provides a variation where the query predicate includes the application identifier as well as the expected state of the data in the write operation.</p>\n\n<h3>Remove</h3>\n<p>Remove All Documents That Match a Condition</p>\n<pre>db.restaurants.remove( { \"borough\": \"Manhattan\" } )</pre>\n\n<h3>justOne Option</h3>\n<pre>db.restaurants.remove( { \"borough\": \"Queens\" }, { justOne: true } )</pre>\n\n<h3>Remove All</h3>\n<pre>\ndb.restaurants.remove( { } )\n</pre>\n\n<h3>Drop a Collection</h3>\n<p>The remove all operation only removes the documents from the collection. The collection itself, as well as any indexes for the collection, remain. To remove all documents from a collection, it may be more efficient to drop the entire collection, including the indexes, and then recreate the collection and rebuild the indexes. Use the drop() method to drop a collection, including any indexes.</p>\n\n<pre>db.restaurants.drop()</pre>\n\n<p></p>";
},"useData":true});

this["JST"]["./modules/templates/NaN.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>This is the only value in JavaScript that is not equal to itself.</p>\n\n<blockquote>NaN is supposed to denote the result of a nonsensical computation and as such, it isn't equal to the result of <em>other</em> nonsensical compoutations.</blockquote>";
},"useData":true});

this["JST"]["./modules/templates/Recursion.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>Recursion in programming is simply a function that calls itself. </p>";
},"useData":true});

this["JST"]["./modules/templates/TypeConversion.hbs"] = Handlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<p>JavaScript's automatic type conversion or <em>type coersion</em> can be tricky. When a statement expects a value of a certain type and the expression passed to it does not return one of that type, JavaScript will attempt to convert the given expression into the type it is looking for.</p>\n\n<pre>\nvar e = {ex:1};\nif(e) {\n    // converted from an object to boolean\n}\n</pre>\n\n<p>Usually, this is helpful, but sometimes it can lead to unexpected results. For example, the + operator will always concatenate values if one is a string, otherwise it will add two values together. In the example below, the number 1 is converted to a string.</p>\n<pre>\n'99' + 1\n// '991'\n</pre>\n\n<p>But, the - operator will trigger a type conversion when applied to a string or strings, attempting to convert them to numeric values.</p>\n<pre>\n'99' - '1'\n// 98\n</pre>\n\n<p><code class=\"language-javascript\">true</code> converts to 1 when expected in an arithmetic operation and <code>null</code> converts to 0</p>\n<pre>\ntrue + 2\n// 3\nnull * 1\n// 0\n</pre>\n\n<p>Logical operators (<code>||</code> or <code>&&</code>) work on all types. They <em>expect</em> boolean values though, so when presented with a non-boolean, they will convert it. If it converts to true, they return the <em>original</em> value. For this reason, logical operators are extremely useful in allowing for fallback values and null checks.</p>\n<p>The below code is an example of 'short-circuiting' an evaluation. Since a is <code>null</code>, we fall back to the secondary value. But, if a had evaluated to <code>true</code>, then the second expression would <em>never</em> be evaluated.</p>\n<pre>\nvar a = null\nvar b = a || 'fallback value'\nb // 'fallback value'\n</pre>\n<p>Below, we are using the logical operator to perform a null check on a value we receieved for an imaginary API. If we tried to access c.inner.inner without the null check and <code>c</code> or <code>c.inner</code> did not exist, we would get a \"Cannot read property 'inner' of undefined error.\" But, since we performed the check, the worst that can happen is the <code>if</code> conditional returns false and the program moves right along.</p>\n<pre>\nvar c = getSomeAPIDataInJSON();\nif(c && c.inner && c.inner.inner) {\n    console.log(c.inner.inner);\n}\n</pre>\n\n\n\n<p><code>==</code> checks for equality regardless of the type. Type conversion is performed here.</p>\n<p><code>===</code> checks for equality <em>and</em> matching type. It actually runs faster since we are avoiding a type conversion here. This should be used when possible.</p>\n\n<pre>\nnull == 0\n// false\nnull == ''\n// false\nnull == false\n// false\nnull == undefined\n// true\nnull === undefined\n// false\n</pre>\n\n<p>What counts as false?</p>\n<pre>\n'' == false\nNaN == false\n0 == false\nundefined == false\n// all true\n</pre>\n\n";
},"useData":true});